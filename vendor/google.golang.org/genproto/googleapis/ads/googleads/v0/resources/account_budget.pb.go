// Code generated by protoc-gen-go. DO NOT EDIT.
// source: google/ads/googleads/v0/resources/account_budget.proto

package resources // import "google.golang.org/genproto/googleapis/ads/googleads/v0/resources"

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import wrappers "github.com/golang/protobuf/ptypes/wrappers"
import enums "google.golang.org/genproto/googleapis/ads/googleads/v0/enums"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// An account-level budget. It contains information about the budget itself,
// as well as the most recently approved changes to the budget and proposed
// changes that are pending approval. The proposed changes that are pending
// approval, if any, are found in 'pending_proposal'.  Effective details about
// the budget are found in fields prefixed 'approved_', 'adjusted_' and those
// without a prefix.  Since some effective details may differ from what the user
// had originally requested (e.g. spending limit), these differences are
// juxtaposed via 'proposed_', 'approved_', and possibly 'adjusted_' fields.
//
// This resource is mutated using AccountBudgetProposal and cannot be mutated
// directly. A budget may have at most one pending proposal at any given time.
// It is read through pending_proposal.
//
// Once approved, a budget may be subject to adjustments, such as credit
// adjustments.  Adjustments create differences between the 'approved' and
// 'adjusted' fields, which would otherwise be identical.
type AccountBudget struct {
	// The resource name of the account-level budget.
	// AccountBudget resource names have the form:
	//
	// `customers/{customer_id}/accountBudgets/{account_budget_id}`
	ResourceName string `protobuf:"bytes,1,opt,name=resource_name,json=resourceName,proto3" json:"resource_name,omitempty"`
	// The ID of the account-level budget.
	Id *wrappers.Int64Value `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// The resource name of the billing setup associated with this account-level
	// budget.  BillingSetup resource names have the form:
	//
	// `customers/{customer_id}/billingSetups/{billing_setup_id}`
	BillingSetup *wrappers.StringValue `protobuf:"bytes,3,opt,name=billing_setup,json=billingSetup,proto3" json:"billing_setup,omitempty"`
	// The status of this account-level budget.
	Status enums.AccountBudgetStatusEnum_AccountBudgetStatus `protobuf:"varint,4,opt,name=status,proto3,enum=google.ads.googleads.v0.enums.AccountBudgetStatusEnum_AccountBudgetStatus" json:"status,omitempty"`
	// The name of the account-level budget.
	Name *wrappers.StringValue `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	// The proposed start time of the account-level budget in
	// yyyy-MM-dd HH:mm:ss format.  If a start time type of NOW was proposed,
	// this is the time of request.
	ProposedStartDateTime *wrappers.StringValue `protobuf:"bytes,6,opt,name=proposed_start_date_time,json=proposedStartDateTime,proto3" json:"proposed_start_date_time,omitempty"`
	// The approved start time of the account-level budget in yyyy-MM-dd HH:mm:ss
	// format.
	//
	// For example, if a new budget is approved after the proposed start time,
	// the approved start time is the time of approval.
	ApprovedStartDateTime *wrappers.StringValue `protobuf:"bytes,7,opt,name=approved_start_date_time,json=approvedStartDateTime,proto3" json:"approved_start_date_time,omitempty"`
	// The total adjustments amount.
	//
	// An example of an adjustment is courtesy credits.
	TotalAdjustmentsMicros *wrappers.Int64Value `protobuf:"bytes,18,opt,name=total_adjustments_micros,json=totalAdjustmentsMicros,proto3" json:"total_adjustments_micros,omitempty"`
	// The value of Ads that have been served, in micros.
	//
	// This includes overdelivery costs, in which case a credit might be
	// automatically applied to the budget (see total_adjustments_micros).
	AmountServedMicros *wrappers.Int64Value `protobuf:"bytes,19,opt,name=amount_served_micros,json=amountServedMicros,proto3" json:"amount_served_micros,omitempty"`
	// A purchase order number is a value that helps users reference this budget
	// in their monthly invoices.
	PurchaseOrderNumber *wrappers.StringValue `protobuf:"bytes,20,opt,name=purchase_order_number,json=purchaseOrderNumber,proto3" json:"purchase_order_number,omitempty"`
	// Notes associated with the budget.
	Notes *wrappers.StringValue `protobuf:"bytes,21,opt,name=notes,proto3" json:"notes,omitempty"`
	// The pending proposal to modify this budget, if applicable.
	PendingProposal *AccountBudget_PendingAccountBudgetProposal `protobuf:"bytes,22,opt,name=pending_proposal,json=pendingProposal,proto3" json:"pending_proposal,omitempty"`
	// The proposed end time of the account-level budget.
	//
	// Types that are valid to be assigned to ProposedEndTime:
	//	*AccountBudget_ProposedEndDateTime
	//	*AccountBudget_ProposedEndTimeType
	ProposedEndTime isAccountBudget_ProposedEndTime `protobuf_oneof:"proposed_end_time"`
	// The approved end time of the account-level budget.
	//
	// For example, if a budget's end time is updated and the proposal is approved
	// after the proposed end time, the approved end time is the time of approval.
	//
	// Types that are valid to be assigned to ApprovedEndTime:
	//	*AccountBudget_ApprovedEndDateTime
	//	*AccountBudget_ApprovedEndTimeType
	ApprovedEndTime isAccountBudget_ApprovedEndTime `protobuf_oneof:"approved_end_time"`
	// The proposed spending limit.
	//
	// Types that are valid to be assigned to ProposedSpendingLimit:
	//	*AccountBudget_ProposedSpendingLimitMicros
	//	*AccountBudget_ProposedSpendingLimitType
	ProposedSpendingLimit isAccountBudget_ProposedSpendingLimit `protobuf_oneof:"proposed_spending_limit"`
	// The approved spending limit.
	//
	// For example, if the amount already spent by the account exceeds the
	// proposed spending limit at the time the proposal is approved, the approved
	// spending limit is set to the amount already spent.
	//
	// Types that are valid to be assigned to ApprovedSpendingLimit:
	//	*AccountBudget_ApprovedSpendingLimitMicros
	//	*AccountBudget_ApprovedSpendingLimitType
	ApprovedSpendingLimit isAccountBudget_ApprovedSpendingLimit `protobuf_oneof:"approved_spending_limit"`
	// The spending limit after adjustments have been applied.  Adjustments are
	// stored in total_adjustments_micros.
	//
	// This value has the final say on how much the account is allowed to spend.
	//
	// Types that are valid to be assigned to AdjustedSpendingLimit:
	//	*AccountBudget_AdjustedSpendingLimitMicros
	//	*AccountBudget_AdjustedSpendingLimitType
	AdjustedSpendingLimit isAccountBudget_AdjustedSpendingLimit `protobuf_oneof:"adjusted_spending_limit"`
	XXX_NoUnkeyedLiteral  struct{}                              `json:"-"`
	XXX_unrecognized      []byte                                `json:"-"`
	XXX_sizecache         int32                                 `json:"-"`
}

func (m *AccountBudget) Reset()         { *m = AccountBudget{} }
func (m *AccountBudget) String() string { return proto.CompactTextString(m) }
func (*AccountBudget) ProtoMessage()    {}
func (*AccountBudget) Descriptor() ([]byte, []int) {
	return fileDescriptor_account_budget_b49b5199235ca7bd, []int{0}
}
func (m *AccountBudget) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AccountBudget.Unmarshal(m, b)
}
func (m *AccountBudget) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AccountBudget.Marshal(b, m, deterministic)
}
func (dst *AccountBudget) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountBudget.Merge(dst, src)
}
func (m *AccountBudget) XXX_Size() int {
	return xxx_messageInfo_AccountBudget.Size(m)
}
func (m *AccountBudget) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountBudget.DiscardUnknown(m)
}

var xxx_messageInfo_AccountBudget proto.InternalMessageInfo

func (m *AccountBudget) GetResourceName() string {
	if m != nil {
		return m.ResourceName
	}
	return ""
}

func (m *AccountBudget) GetId() *wrappers.Int64Value {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *AccountBudget) GetBillingSetup() *wrappers.StringValue {
	if m != nil {
		return m.BillingSetup
	}
	return nil
}

func (m *AccountBudget) GetStatus() enums.AccountBudgetStatusEnum_AccountBudgetStatus {
	if m != nil {
		return m.Status
	}
	return enums.AccountBudgetStatusEnum_UNSPECIFIED
}

func (m *AccountBudget) GetName() *wrappers.StringValue {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *AccountBudget) GetProposedStartDateTime() *wrappers.StringValue {
	if m != nil {
		return m.ProposedStartDateTime
	}
	return nil
}

func (m *AccountBudget) GetApprovedStartDateTime() *wrappers.StringValue {
	if m != nil {
		return m.ApprovedStartDateTime
	}
	return nil
}

func (m *AccountBudget) GetTotalAdjustmentsMicros() *wrappers.Int64Value {
	if m != nil {
		return m.TotalAdjustmentsMicros
	}
	return nil
}

func (m *AccountBudget) GetAmountServedMicros() *wrappers.Int64Value {
	if m != nil {
		return m.AmountServedMicros
	}
	return nil
}

func (m *AccountBudget) GetPurchaseOrderNumber() *wrappers.StringValue {
	if m != nil {
		return m.PurchaseOrderNumber
	}
	return nil
}

func (m *AccountBudget) GetNotes() *wrappers.StringValue {
	if m != nil {
		return m.Notes
	}
	return nil
}

func (m *AccountBudget) GetPendingProposal() *AccountBudget_PendingAccountBudgetProposal {
	if m != nil {
		return m.PendingProposal
	}
	return nil
}

type isAccountBudget_ProposedEndTime interface {
	isAccountBudget_ProposedEndTime()
}

type AccountBudget_ProposedEndDateTime struct {
	ProposedEndDateTime *wrappers.StringValue `protobuf:"bytes,8,opt,name=proposed_end_date_time,json=proposedEndDateTime,proto3,oneof"`
}

type AccountBudget_ProposedEndTimeType struct {
	ProposedEndTimeType enums.TimeTypeEnum_TimeType `protobuf:"varint,9,opt,name=proposed_end_time_type,json=proposedEndTimeType,proto3,enum=google.ads.googleads.v0.enums.TimeTypeEnum_TimeType,oneof"`
}

func (*AccountBudget_ProposedEndDateTime) isAccountBudget_ProposedEndTime() {}

func (*AccountBudget_ProposedEndTimeType) isAccountBudget_ProposedEndTime() {}

func (m *AccountBudget) GetProposedEndTime() isAccountBudget_ProposedEndTime {
	if m != nil {
		return m.ProposedEndTime
	}
	return nil
}

func (m *AccountBudget) GetProposedEndDateTime() *wrappers.StringValue {
	if x, ok := m.GetProposedEndTime().(*AccountBudget_ProposedEndDateTime); ok {
		return x.ProposedEndDateTime
	}
	return nil
}

func (m *AccountBudget) GetProposedEndTimeType() enums.TimeTypeEnum_TimeType {
	if x, ok := m.GetProposedEndTime().(*AccountBudget_ProposedEndTimeType); ok {
		return x.ProposedEndTimeType
	}
	return enums.TimeTypeEnum_UNSPECIFIED
}

type isAccountBudget_ApprovedEndTime interface {
	isAccountBudget_ApprovedEndTime()
}

type AccountBudget_ApprovedEndDateTime struct {
	ApprovedEndDateTime *wrappers.StringValue `protobuf:"bytes,10,opt,name=approved_end_date_time,json=approvedEndDateTime,proto3,oneof"`
}

type AccountBudget_ApprovedEndTimeType struct {
	ApprovedEndTimeType enums.TimeTypeEnum_TimeType `protobuf:"varint,11,opt,name=approved_end_time_type,json=approvedEndTimeType,proto3,enum=google.ads.googleads.v0.enums.TimeTypeEnum_TimeType,oneof"`
}

func (*AccountBudget_ApprovedEndDateTime) isAccountBudget_ApprovedEndTime() {}

func (*AccountBudget_ApprovedEndTimeType) isAccountBudget_ApprovedEndTime() {}

func (m *AccountBudget) GetApprovedEndTime() isAccountBudget_ApprovedEndTime {
	if m != nil {
		return m.ApprovedEndTime
	}
	return nil
}

func (m *AccountBudget) GetApprovedEndDateTime() *wrappers.StringValue {
	if x, ok := m.GetApprovedEndTime().(*AccountBudget_ApprovedEndDateTime); ok {
		return x.ApprovedEndDateTime
	}
	return nil
}

func (m *AccountBudget) GetApprovedEndTimeType() enums.TimeTypeEnum_TimeType {
	if x, ok := m.GetApprovedEndTime().(*AccountBudget_ApprovedEndTimeType); ok {
		return x.ApprovedEndTimeType
	}
	return enums.TimeTypeEnum_UNSPECIFIED
}

type isAccountBudget_ProposedSpendingLimit interface {
	isAccountBudget_ProposedSpendingLimit()
}

type AccountBudget_ProposedSpendingLimitMicros struct {
	ProposedSpendingLimitMicros *wrappers.Int64Value `protobuf:"bytes,12,opt,name=proposed_spending_limit_micros,json=proposedSpendingLimitMicros,proto3,oneof"`
}

type AccountBudget_ProposedSpendingLimitType struct {
	ProposedSpendingLimitType enums.SpendingLimitTypeEnum_SpendingLimitType `protobuf:"varint,13,opt,name=proposed_spending_limit_type,json=proposedSpendingLimitType,proto3,enum=google.ads.googleads.v0.enums.SpendingLimitTypeEnum_SpendingLimitType,oneof"`
}

func (*AccountBudget_ProposedSpendingLimitMicros) isAccountBudget_ProposedSpendingLimit() {}

func (*AccountBudget_ProposedSpendingLimitType) isAccountBudget_ProposedSpendingLimit() {}

func (m *AccountBudget) GetProposedSpendingLimit() isAccountBudget_ProposedSpendingLimit {
	if m != nil {
		return m.ProposedSpendingLimit
	}
	return nil
}

func (m *AccountBudget) GetProposedSpendingLimitMicros() *wrappers.Int64Value {
	if x, ok := m.GetProposedSpendingLimit().(*AccountBudget_ProposedSpendingLimitMicros); ok {
		return x.ProposedSpendingLimitMicros
	}
	return nil
}

func (m *AccountBudget) GetProposedSpendingLimitType() enums.SpendingLimitTypeEnum_SpendingLimitType {
	if x, ok := m.GetProposedSpendingLimit().(*AccountBudget_ProposedSpendingLimitType); ok {
		return x.ProposedSpendingLimitType
	}
	return enums.SpendingLimitTypeEnum_UNSPECIFIED
}

type isAccountBudget_ApprovedSpendingLimit interface {
	isAccountBudget_ApprovedSpendingLimit()
}

type AccountBudget_ApprovedSpendingLimitMicros struct {
	ApprovedSpendingLimitMicros *wrappers.Int64Value `protobuf:"bytes,14,opt,name=approved_spending_limit_micros,json=approvedSpendingLimitMicros,proto3,oneof"`
}

type AccountBudget_ApprovedSpendingLimitType struct {
	ApprovedSpendingLimitType enums.SpendingLimitTypeEnum_SpendingLimitType `protobuf:"varint,15,opt,name=approved_spending_limit_type,json=approvedSpendingLimitType,proto3,enum=google.ads.googleads.v0.enums.SpendingLimitTypeEnum_SpendingLimitType,oneof"`
}

func (*AccountBudget_ApprovedSpendingLimitMicros) isAccountBudget_ApprovedSpendingLimit() {}

func (*AccountBudget_ApprovedSpendingLimitType) isAccountBudget_ApprovedSpendingLimit() {}

func (m *AccountBudget) GetApprovedSpendingLimit() isAccountBudget_ApprovedSpendingLimit {
	if m != nil {
		return m.ApprovedSpendingLimit
	}
	return nil
}

func (m *AccountBudget) GetApprovedSpendingLimitMicros() *wrappers.Int64Value {
	if x, ok := m.GetApprovedSpendingLimit().(*AccountBudget_ApprovedSpendingLimitMicros); ok {
		return x.ApprovedSpendingLimitMicros
	}
	return nil
}

func (m *AccountBudget) GetApprovedSpendingLimitType() enums.SpendingLimitTypeEnum_SpendingLimitType {
	if x, ok := m.GetApprovedSpendingLimit().(*AccountBudget_ApprovedSpendingLimitType); ok {
		return x.ApprovedSpendingLimitType
	}
	return enums.SpendingLimitTypeEnum_UNSPECIFIED
}

type isAccountBudget_AdjustedSpendingLimit interface {
	isAccountBudget_AdjustedSpendingLimit()
}

type AccountBudget_AdjustedSpendingLimitMicros struct {
	AdjustedSpendingLimitMicros *wrappers.Int64Value `protobuf:"bytes,16,opt,name=adjusted_spending_limit_micros,json=adjustedSpendingLimitMicros,proto3,oneof"`
}

type AccountBudget_AdjustedSpendingLimitType struct {
	AdjustedSpendingLimitType enums.SpendingLimitTypeEnum_SpendingLimitType `protobuf:"varint,17,opt,name=adjusted_spending_limit_type,json=adjustedSpendingLimitType,proto3,enum=google.ads.googleads.v0.enums.SpendingLimitTypeEnum_SpendingLimitType,oneof"`
}

func (*AccountBudget_AdjustedSpendingLimitMicros) isAccountBudget_AdjustedSpendingLimit() {}

func (*AccountBudget_AdjustedSpendingLimitType) isAccountBudget_AdjustedSpendingLimit() {}

func (m *AccountBudget) GetAdjustedSpendingLimit() isAccountBudget_AdjustedSpendingLimit {
	if m != nil {
		return m.AdjustedSpendingLimit
	}
	return nil
}

func (m *AccountBudget) GetAdjustedSpendingLimitMicros() *wrappers.Int64Value {
	if x, ok := m.GetAdjustedSpendingLimit().(*AccountBudget_AdjustedSpendingLimitMicros); ok {
		return x.AdjustedSpendingLimitMicros
	}
	return nil
}

func (m *AccountBudget) GetAdjustedSpendingLimitType() enums.SpendingLimitTypeEnum_SpendingLimitType {
	if x, ok := m.GetAdjustedSpendingLimit().(*AccountBudget_AdjustedSpendingLimitType); ok {
		return x.AdjustedSpendingLimitType
	}
	return enums.SpendingLimitTypeEnum_UNSPECIFIED
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AccountBudget) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AccountBudget_OneofMarshaler, _AccountBudget_OneofUnmarshaler, _AccountBudget_OneofSizer, []interface{}{
		(*AccountBudget_ProposedEndDateTime)(nil),
		(*AccountBudget_ProposedEndTimeType)(nil),
		(*AccountBudget_ApprovedEndDateTime)(nil),
		(*AccountBudget_ApprovedEndTimeType)(nil),
		(*AccountBudget_ProposedSpendingLimitMicros)(nil),
		(*AccountBudget_ProposedSpendingLimitType)(nil),
		(*AccountBudget_ApprovedSpendingLimitMicros)(nil),
		(*AccountBudget_ApprovedSpendingLimitType)(nil),
		(*AccountBudget_AdjustedSpendingLimitMicros)(nil),
		(*AccountBudget_AdjustedSpendingLimitType)(nil),
	}
}

func _AccountBudget_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AccountBudget)
	// proposed_end_time
	switch x := m.ProposedEndTime.(type) {
	case *AccountBudget_ProposedEndDateTime:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ProposedEndDateTime); err != nil {
			return err
		}
	case *AccountBudget_ProposedEndTimeType:
		b.EncodeVarint(9<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.ProposedEndTimeType))
	case nil:
	default:
		return fmt.Errorf("AccountBudget.ProposedEndTime has unexpected type %T", x)
	}
	// approved_end_time
	switch x := m.ApprovedEndTime.(type) {
	case *AccountBudget_ApprovedEndDateTime:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ApprovedEndDateTime); err != nil {
			return err
		}
	case *AccountBudget_ApprovedEndTimeType:
		b.EncodeVarint(11<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.ApprovedEndTimeType))
	case nil:
	default:
		return fmt.Errorf("AccountBudget.ApprovedEndTime has unexpected type %T", x)
	}
	// proposed_spending_limit
	switch x := m.ProposedSpendingLimit.(type) {
	case *AccountBudget_ProposedSpendingLimitMicros:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ProposedSpendingLimitMicros); err != nil {
			return err
		}
	case *AccountBudget_ProposedSpendingLimitType:
		b.EncodeVarint(13<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.ProposedSpendingLimitType))
	case nil:
	default:
		return fmt.Errorf("AccountBudget.ProposedSpendingLimit has unexpected type %T", x)
	}
	// approved_spending_limit
	switch x := m.ApprovedSpendingLimit.(type) {
	case *AccountBudget_ApprovedSpendingLimitMicros:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ApprovedSpendingLimitMicros); err != nil {
			return err
		}
	case *AccountBudget_ApprovedSpendingLimitType:
		b.EncodeVarint(15<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.ApprovedSpendingLimitType))
	case nil:
	default:
		return fmt.Errorf("AccountBudget.ApprovedSpendingLimit has unexpected type %T", x)
	}
	// adjusted_spending_limit
	switch x := m.AdjustedSpendingLimit.(type) {
	case *AccountBudget_AdjustedSpendingLimitMicros:
		b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AdjustedSpendingLimitMicros); err != nil {
			return err
		}
	case *AccountBudget_AdjustedSpendingLimitType:
		b.EncodeVarint(17<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.AdjustedSpendingLimitType))
	case nil:
	default:
		return fmt.Errorf("AccountBudget.AdjustedSpendingLimit has unexpected type %T", x)
	}
	return nil
}

func _AccountBudget_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AccountBudget)
	switch tag {
	case 8: // proposed_end_time.proposed_end_date_time
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(wrappers.StringValue)
		err := b.DecodeMessage(msg)
		m.ProposedEndTime = &AccountBudget_ProposedEndDateTime{msg}
		return true, err
	case 9: // proposed_end_time.proposed_end_time_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ProposedEndTime = &AccountBudget_ProposedEndTimeType{enums.TimeTypeEnum_TimeType(x)}
		return true, err
	case 10: // approved_end_time.approved_end_date_time
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(wrappers.StringValue)
		err := b.DecodeMessage(msg)
		m.ApprovedEndTime = &AccountBudget_ApprovedEndDateTime{msg}
		return true, err
	case 11: // approved_end_time.approved_end_time_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ApprovedEndTime = &AccountBudget_ApprovedEndTimeType{enums.TimeTypeEnum_TimeType(x)}
		return true, err
	case 12: // proposed_spending_limit.proposed_spending_limit_micros
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(wrappers.Int64Value)
		err := b.DecodeMessage(msg)
		m.ProposedSpendingLimit = &AccountBudget_ProposedSpendingLimitMicros{msg}
		return true, err
	case 13: // proposed_spending_limit.proposed_spending_limit_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ProposedSpendingLimit = &AccountBudget_ProposedSpendingLimitType{enums.SpendingLimitTypeEnum_SpendingLimitType(x)}
		return true, err
	case 14: // approved_spending_limit.approved_spending_limit_micros
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(wrappers.Int64Value)
		err := b.DecodeMessage(msg)
		m.ApprovedSpendingLimit = &AccountBudget_ApprovedSpendingLimitMicros{msg}
		return true, err
	case 15: // approved_spending_limit.approved_spending_limit_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ApprovedSpendingLimit = &AccountBudget_ApprovedSpendingLimitType{enums.SpendingLimitTypeEnum_SpendingLimitType(x)}
		return true, err
	case 16: // adjusted_spending_limit.adjusted_spending_limit_micros
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(wrappers.Int64Value)
		err := b.DecodeMessage(msg)
		m.AdjustedSpendingLimit = &AccountBudget_AdjustedSpendingLimitMicros{msg}
		return true, err
	case 17: // adjusted_spending_limit.adjusted_spending_limit_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.AdjustedSpendingLimit = &AccountBudget_AdjustedSpendingLimitType{enums.SpendingLimitTypeEnum_SpendingLimitType(x)}
		return true, err
	default:
		return false, nil
	}
}

func _AccountBudget_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AccountBudget)
	// proposed_end_time
	switch x := m.ProposedEndTime.(type) {
	case *AccountBudget_ProposedEndDateTime:
		s := proto.Size(x.ProposedEndDateTime)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccountBudget_ProposedEndTimeType:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.ProposedEndTimeType))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// approved_end_time
	switch x := m.ApprovedEndTime.(type) {
	case *AccountBudget_ApprovedEndDateTime:
		s := proto.Size(x.ApprovedEndDateTime)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccountBudget_ApprovedEndTimeType:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.ApprovedEndTimeType))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// proposed_spending_limit
	switch x := m.ProposedSpendingLimit.(type) {
	case *AccountBudget_ProposedSpendingLimitMicros:
		s := proto.Size(x.ProposedSpendingLimitMicros)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccountBudget_ProposedSpendingLimitType:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.ProposedSpendingLimitType))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// approved_spending_limit
	switch x := m.ApprovedSpendingLimit.(type) {
	case *AccountBudget_ApprovedSpendingLimitMicros:
		s := proto.Size(x.ApprovedSpendingLimitMicros)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccountBudget_ApprovedSpendingLimitType:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.ApprovedSpendingLimitType))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// adjusted_spending_limit
	switch x := m.AdjustedSpendingLimit.(type) {
	case *AccountBudget_AdjustedSpendingLimitMicros:
		s := proto.Size(x.AdjustedSpendingLimitMicros)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccountBudget_AdjustedSpendingLimitType:
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(x.AdjustedSpendingLimitType))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A pending proposal associated with the enclosing account-level budget,
// if applicable.
type AccountBudget_PendingAccountBudgetProposal struct {
	// The resource name of the proposal.
	// AccountBudgetProposal resource names have the form:
	//
	//
	// `customers/{customer_id}/accountBudgetProposals/{account_budget_proposal_id}`
	AccountBudgetProposal *wrappers.StringValue `protobuf:"bytes,1,opt,name=account_budget_proposal,json=accountBudgetProposal,proto3" json:"account_budget_proposal,omitempty"`
	// The type of this proposal, e.g. END to end the budget associated
	// with this proposal.
	ProposalType enums.AccountBudgetProposalTypeEnum_AccountBudgetProposalType `protobuf:"varint,2,opt,name=proposal_type,json=proposalType,proto3,enum=google.ads.googleads.v0.enums.AccountBudgetProposalTypeEnum_AccountBudgetProposalType" json:"proposal_type,omitempty"`
	// The name to assign to the account-level budget.
	Name *wrappers.StringValue `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// The start time in yyyy-MM-dd HH:mm:ss format.
	StartDateTime *wrappers.StringValue `protobuf:"bytes,4,opt,name=start_date_time,json=startDateTime,proto3" json:"start_date_time,omitempty"`
	// A purchase order number is a value that helps users reference this budget
	// in their monthly invoices.
	PurchaseOrderNumber *wrappers.StringValue `protobuf:"bytes,9,opt,name=purchase_order_number,json=purchaseOrderNumber,proto3" json:"purchase_order_number,omitempty"`
	// Notes associated with this budget.
	Notes *wrappers.StringValue `protobuf:"bytes,10,opt,name=notes,proto3" json:"notes,omitempty"`
	// The time when this account-level budget proposal was created.
	// Formatted as yyyy-MM-dd HH:mm:ss.
	CreationDateTime *wrappers.StringValue `protobuf:"bytes,11,opt,name=creation_date_time,json=creationDateTime,proto3" json:"creation_date_time,omitempty"`
	// The end time of the account-level budget.
	//
	// Types that are valid to be assigned to EndTime:
	//	*AccountBudget_PendingAccountBudgetProposal_EndDateTime
	//	*AccountBudget_PendingAccountBudgetProposal_EndTimeType
	EndTime isAccountBudget_PendingAccountBudgetProposal_EndTime `protobuf_oneof:"end_time"`
	// The spending limit.
	//
	// Types that are valid to be assigned to SpendingLimit:
	//	*AccountBudget_PendingAccountBudgetProposal_SpendingLimitMicros
	//	*AccountBudget_PendingAccountBudgetProposal_SpendingLimitType
	SpendingLimit        isAccountBudget_PendingAccountBudgetProposal_SpendingLimit `protobuf_oneof:"spending_limit"`
	XXX_NoUnkeyedLiteral struct{}                                                   `json:"-"`
	XXX_unrecognized     []byte                                                     `json:"-"`
	XXX_sizecache        int32                                                      `json:"-"`
}

func (m *AccountBudget_PendingAccountBudgetProposal) Reset() {
	*m = AccountBudget_PendingAccountBudgetProposal{}
}
func (m *AccountBudget_PendingAccountBudgetProposal) String() string {
	return proto.CompactTextString(m)
}
func (*AccountBudget_PendingAccountBudgetProposal) ProtoMessage() {}
func (*AccountBudget_PendingAccountBudgetProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_account_budget_b49b5199235ca7bd, []int{0, 0}
}
func (m *AccountBudget_PendingAccountBudgetProposal) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AccountBudget_PendingAccountBudgetProposal.Unmarshal(m, b)
}
func (m *AccountBudget_PendingAccountBudgetProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AccountBudget_PendingAccountBudgetProposal.Marshal(b, m, deterministic)
}
func (dst *AccountBudget_PendingAccountBudgetProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountBudget_PendingAccountBudgetProposal.Merge(dst, src)
}
func (m *AccountBudget_PendingAccountBudgetProposal) XXX_Size() int {
	return xxx_messageInfo_AccountBudget_PendingAccountBudgetProposal.Size(m)
}
func (m *AccountBudget_PendingAccountBudgetProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountBudget_PendingAccountBudgetProposal.DiscardUnknown(m)
}

var xxx_messageInfo_AccountBudget_PendingAccountBudgetProposal proto.InternalMessageInfo

func (m *AccountBudget_PendingAccountBudgetProposal) GetAccountBudgetProposal() *wrappers.StringValue {
	if m != nil {
		return m.AccountBudgetProposal
	}
	return nil
}

func (m *AccountBudget_PendingAccountBudgetProposal) GetProposalType() enums.AccountBudgetProposalTypeEnum_AccountBudgetProposalType {
	if m != nil {
		return m.ProposalType
	}
	return enums.AccountBudgetProposalTypeEnum_UNSPECIFIED
}

func (m *AccountBudget_PendingAccountBudgetProposal) GetName() *wrappers.StringValue {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *AccountBudget_PendingAccountBudgetProposal) GetStartDateTime() *wrappers.StringValue {
	if m != nil {
		return m.StartDateTime
	}
	return nil
}

func (m *AccountBudget_PendingAccountBudgetProposal) GetPurchaseOrderNumber() *wrappers.StringValue {
	if m != nil {
		return m.PurchaseOrderNumber
	}
	return nil
}

func (m *AccountBudget_PendingAccountBudgetProposal) GetNotes() *wrappers.StringValue {
	if m != nil {
		return m.Notes
	}
	return nil
}

func (m *AccountBudget_PendingAccountBudgetProposal) GetCreationDateTime() *wrappers.StringValue {
	if m != nil {
		return m.CreationDateTime
	}
	return nil
}

type isAccountBudget_PendingAccountBudgetProposal_EndTime interface {
	isAccountBudget_PendingAccountBudgetProposal_EndTime()
}

type AccountBudget_PendingAccountBudgetProposal_EndDateTime struct {
	EndDateTime *wrappers.StringValue `protobuf:"bytes,5,opt,name=end_date_time,json=endDateTime,proto3,oneof"`
}

type AccountBudget_PendingAccountBudgetProposal_EndTimeType struct {
	EndTimeType enums.TimeTypeEnum_TimeType `protobuf:"varint,6,opt,name=end_time_type,json=endTimeType,proto3,enum=google.ads.googleads.v0.enums.TimeTypeEnum_TimeType,oneof"`
}

func (*AccountBudget_PendingAccountBudgetProposal_EndDateTime) isAccountBudget_PendingAccountBudgetProposal_EndTime() {
}

func (*AccountBudget_PendingAccountBudgetProposal_EndTimeType) isAccountBudget_PendingAccountBudgetProposal_EndTime() {
}

func (m *AccountBudget_PendingAccountBudgetProposal) GetEndTime() isAccountBudget_PendingAccountBudgetProposal_EndTime {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *AccountBudget_PendingAccountBudgetProposal) GetEndDateTime() *wrappers.StringValue {
	if x, ok := m.GetEndTime().(*AccountBudget_PendingAccountBudgetProposal_EndDateTime); ok {
		return x.EndDateTime
	}
	return nil
}

func (m *AccountBudget_PendingAccountBudgetProposal) GetEndTimeType() enums.TimeTypeEnum_TimeType {
	if x, ok := m.GetEndTime().(*AccountBudget_PendingAccountBudgetProposal_EndTimeType); ok {
		return x.EndTimeType
	}
	return enums.TimeTypeEnum_UNSPECIFIED
}

type isAccountBudget_PendingAccountBudgetProposal_SpendingLimit interface {
	isAccountBudget_PendingAccountBudgetProposal_SpendingLimit()
}

type AccountBudget_PendingAccountBudgetProposal_SpendingLimitMicros struct {
	SpendingLimitMicros *wrappers.Int64Value `protobuf:"bytes,7,opt,name=spending_limit_micros,json=spendingLimitMicros,proto3,oneof"`
}

type AccountBudget_PendingAccountBudgetProposal_SpendingLimitType struct {
	SpendingLimitType enums.SpendingLimitTypeEnum_SpendingLimitType `protobuf:"varint,8,opt,name=spending_limit_type,json=spendingLimitType,proto3,enum=google.ads.googleads.v0.enums.SpendingLimitTypeEnum_SpendingLimitType,oneof"`
}

func (*AccountBudget_PendingAccountBudgetProposal_SpendingLimitMicros) isAccountBudget_PendingAccountBudgetProposal_SpendingLimit() {
}

func (*AccountBudget_PendingAccountBudgetProposal_SpendingLimitType) isAccountBudget_PendingAccountBudgetProposal_SpendingLimit() {
}

func (m *AccountBudget_PendingAccountBudgetProposal) GetSpendingLimit() isAccountBudget_PendingAccountBudgetProposal_SpendingLimit {
	if m != nil {
		return m.SpendingLimit
	}
	return nil
}

func (m *AccountBudget_PendingAccountBudgetProposal) GetSpendingLimitMicros() *wrappers.Int64Value {
	if x, ok := m.GetSpendingLimit().(*AccountBudget_PendingAccountBudgetProposal_SpendingLimitMicros); ok {
		return x.SpendingLimitMicros
	}
	return nil
}

func (m *AccountBudget_PendingAccountBudgetProposal) GetSpendingLimitType() enums.SpendingLimitTypeEnum_SpendingLimitType {
	if x, ok := m.GetSpendingLimit().(*AccountBudget_PendingAccountBudgetProposal_SpendingLimitType); ok {
		return x.SpendingLimitType
	}
	return enums.SpendingLimitTypeEnum_UNSPECIFIED
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AccountBudget_PendingAccountBudgetProposal) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AccountBudget_PendingAccountBudgetProposal_OneofMarshaler, _AccountBudget_PendingAccountBudgetProposal_OneofUnmarshaler, _AccountBudget_PendingAccountBudgetProposal_OneofSizer, []interface{}{
		(*AccountBudget_PendingAccountBudgetProposal_EndDateTime)(nil),
		(*AccountBudget_PendingAccountBudgetProposal_EndTimeType)(nil),
		(*AccountBudget_PendingAccountBudgetProposal_SpendingLimitMicros)(nil),
		(*AccountBudget_PendingAccountBudgetProposal_SpendingLimitType)(nil),
	}
}

func _AccountBudget_PendingAccountBudgetProposal_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AccountBudget_PendingAccountBudgetProposal)
	// end_time
	switch x := m.EndTime.(type) {
	case *AccountBudget_PendingAccountBudgetProposal_EndDateTime:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EndDateTime); err != nil {
			return err
		}
	case *AccountBudget_PendingAccountBudgetProposal_EndTimeType:
		b.EncodeVarint(6<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.EndTimeType))
	case nil:
	default:
		return fmt.Errorf("AccountBudget_PendingAccountBudgetProposal.EndTime has unexpected type %T", x)
	}
	// spending_limit
	switch x := m.SpendingLimit.(type) {
	case *AccountBudget_PendingAccountBudgetProposal_SpendingLimitMicros:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SpendingLimitMicros); err != nil {
			return err
		}
	case *AccountBudget_PendingAccountBudgetProposal_SpendingLimitType:
		b.EncodeVarint(8<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.SpendingLimitType))
	case nil:
	default:
		return fmt.Errorf("AccountBudget_PendingAccountBudgetProposal.SpendingLimit has unexpected type %T", x)
	}
	return nil
}

func _AccountBudget_PendingAccountBudgetProposal_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AccountBudget_PendingAccountBudgetProposal)
	switch tag {
	case 5: // end_time.end_date_time
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(wrappers.StringValue)
		err := b.DecodeMessage(msg)
		m.EndTime = &AccountBudget_PendingAccountBudgetProposal_EndDateTime{msg}
		return true, err
	case 6: // end_time.end_time_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.EndTime = &AccountBudget_PendingAccountBudgetProposal_EndTimeType{enums.TimeTypeEnum_TimeType(x)}
		return true, err
	case 7: // spending_limit.spending_limit_micros
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(wrappers.Int64Value)
		err := b.DecodeMessage(msg)
		m.SpendingLimit = &AccountBudget_PendingAccountBudgetProposal_SpendingLimitMicros{msg}
		return true, err
	case 8: // spending_limit.spending_limit_type
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.SpendingLimit = &AccountBudget_PendingAccountBudgetProposal_SpendingLimitType{enums.SpendingLimitTypeEnum_SpendingLimitType(x)}
		return true, err
	default:
		return false, nil
	}
}

func _AccountBudget_PendingAccountBudgetProposal_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AccountBudget_PendingAccountBudgetProposal)
	// end_time
	switch x := m.EndTime.(type) {
	case *AccountBudget_PendingAccountBudgetProposal_EndDateTime:
		s := proto.Size(x.EndDateTime)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccountBudget_PendingAccountBudgetProposal_EndTimeType:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.EndTimeType))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// spending_limit
	switch x := m.SpendingLimit.(type) {
	case *AccountBudget_PendingAccountBudgetProposal_SpendingLimitMicros:
		s := proto.Size(x.SpendingLimitMicros)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccountBudget_PendingAccountBudgetProposal_SpendingLimitType:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.SpendingLimitType))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*AccountBudget)(nil), "google.ads.googleads.v0.resources.AccountBudget")
	proto.RegisterType((*AccountBudget_PendingAccountBudgetProposal)(nil), "google.ads.googleads.v0.resources.AccountBudget.PendingAccountBudgetProposal")
}

func init() {
	proto.RegisterFile("google/ads/googleads/v0/resources/account_budget.proto", fileDescriptor_account_budget_b49b5199235ca7bd)
}

var fileDescriptor_account_budget_b49b5199235ca7bd = []byte{
	// 998 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xdd, 0x6e, 0xdb, 0x36,
	0x14, 0x9e, 0x6c, 0xe7, 0x8f, 0x89, 0xf3, 0x23, 0x37, 0xa9, 0xf2, 0x83, 0x22, 0xdd, 0x50, 0x20,
	0xc0, 0x30, 0xd9, 0xc8, 0x8a, 0x0e, 0xf3, 0x6e, 0x66, 0xa3, 0x5d, 0xb3, 0x60, 0xe9, 0x32, 0x39,
	0xf3, 0x45, 0x11, 0x40, 0xa0, 0x2d, 0x4e, 0xd3, 0x66, 0x91, 0x02, 0x49, 0x65, 0x2d, 0xf6, 0x04,
	0x7b, 0x8d, 0x5d, 0xec, 0x62, 0x0f, 0xb2, 0x8b, 0x3d, 0xca, 0x5e, 0x62, 0x05, 0x29, 0x91, 0xb6,
	0x6c, 0x29, 0x52, 0x90, 0xdc, 0x51, 0xe4, 0xf9, 0xbe, 0x73, 0x3e, 0x92, 0xe7, 0x1c, 0x0a, 0xbc,
	0xf0, 0x09, 0xf1, 0x27, 0xa8, 0x0d, 0x3d, 0xd6, 0x4e, 0x86, 0x62, 0x74, 0xd3, 0x69, 0x53, 0xc4,
	0x48, 0x4c, 0xc7, 0x88, 0xb5, 0xe1, 0x78, 0x4c, 0x62, 0xcc, 0xdd, 0x51, 0xec, 0xf9, 0x88, 0xdb,
	0x11, 0x25, 0x9c, 0x98, 0x4f, 0x13, 0x63, 0x1b, 0x7a, 0xcc, 0xd6, 0x38, 0xfb, 0xa6, 0x63, 0x6b,
	0xdc, 0xc1, 0xd7, 0x45, 0xd4, 0x08, 0xc7, 0xe1, 0x3c, 0xad, 0x1b, 0x51, 0x12, 0x11, 0x06, 0x27,
	0x2e, 0x7f, 0x1f, 0xa1, 0xc4, 0xc9, 0xc1, 0x97, 0x77, 0x62, 0x60, 0x1c, 0xf2, 0x98, 0xa5, 0xd0,
	0x2f, 0x6e, 0x87, 0xb2, 0x08, 0x61, 0x2f, 0xc0, 0xbe, 0x3b, 0x09, 0xc2, 0x80, 0xcf, 0xfa, 0xfc,
	0xec, 0x76, 0x20, 0x0f, 0x42, 0x34, 0x6b, 0xfe, 0x24, 0x35, 0x97, 0x5f, 0xa3, 0xf8, 0xa7, 0xf6,
	0x6f, 0x14, 0x46, 0x11, 0xa2, 0x69, 0x1c, 0x1f, 0xff, 0x65, 0x81, 0x66, 0x2f, 0x89, 0xb3, 0x2f,
	0xc3, 0x34, 0x3f, 0x01, 0x4d, 0xb5, 0x47, 0x2e, 0x86, 0x21, 0xb2, 0x8c, 0x63, 0xe3, 0x64, 0xcd,
	0xd9, 0x50, 0x93, 0x6f, 0x60, 0x88, 0xcc, 0x4f, 0x41, 0x2d, 0xf0, 0xac, 0xda, 0xb1, 0x71, 0xb2,
	0x7e, 0x7a, 0x98, 0x6e, 0xb0, 0xad, 0x7c, 0xd8, 0xdf, 0x62, 0xfe, 0xe2, 0xf9, 0x10, 0x4e, 0x62,
	0xe4, 0xd4, 0x02, 0xcf, 0xec, 0x81, 0xe6, 0x28, 0x98, 0x4c, 0x84, 0x1c, 0x86, 0x78, 0x1c, 0x59,
	0x75, 0x89, 0x3b, 0x5a, 0xc0, 0x0d, 0x38, 0x0d, 0xb0, 0x9f, 0x00, 0x37, 0x52, 0xc8, 0x40, 0x20,
	0xcc, 0x11, 0x58, 0x4e, 0xb6, 0xcf, 0x6a, 0x1c, 0x1b, 0x27, 0x9b, 0xa7, 0xe7, 0x76, 0xd1, 0xf9,
	0xca, 0x6d, 0xb0, 0x33, 0x92, 0x06, 0x12, 0xf9, 0x0a, 0xc7, 0x61, 0xde, 0xbc, 0x93, 0x32, 0x9b,
	0x1d, 0xd0, 0x90, 0x7a, 0x97, 0x2a, 0x44, 0x27, 0x2d, 0xcd, 0x1f, 0x81, 0x95, 0x5c, 0x0b, 0xe4,
	0x89, 0xd3, 0xa5, 0xdc, 0xf5, 0x20, 0x47, 0xae, 0x38, 0x03, 0x6b, 0xb9, 0x02, 0xcb, 0xae, 0x42,
	0x0f, 0x04, 0xf8, 0x25, 0xe4, 0xe8, 0x2a, 0x48, 0x68, 0x61, 0x14, 0x51, 0x72, 0x93, 0x43, 0xbb,
	0x52, 0x85, 0x56, 0xa1, 0x17, 0x68, 0x39, 0xe1, 0x70, 0xe2, 0x42, 0xef, 0x97, 0x98, 0xf1, 0x10,
	0x61, 0xce, 0xdc, 0x30, 0x18, 0x53, 0xc2, 0x2c, 0xb3, 0xfc, 0x24, 0xf7, 0x24, 0xb8, 0x37, 0xc5,
	0x5e, 0x48, 0xa8, 0x79, 0x01, 0x1e, 0xc1, 0x50, 0xde, 0x73, 0x86, 0xa8, 0x08, 0x39, 0xa5, 0x6c,
	0x95, 0x53, 0x9a, 0x09, 0x70, 0x20, 0x71, 0x29, 0xdd, 0x25, 0xd8, 0x8d, 0x62, 0x3a, 0xfe, 0x19,
	0x32, 0xe4, 0x12, 0xea, 0x21, 0xea, 0xe2, 0x38, 0x1c, 0x21, 0x6a, 0x3d, 0xaa, 0xa0, 0xbc, 0xa5,
	0xa0, 0xdf, 0x0b, 0xe4, 0x1b, 0x09, 0x34, 0x4f, 0xc1, 0x12, 0x26, 0x1c, 0x31, 0x6b, 0xb7, 0x02,
	0x43, 0x62, 0x6a, 0xbe, 0x03, 0xdb, 0x2a, 0x03, 0x55, 0xe2, 0x5b, 0x7b, 0x12, 0x7e, 0x61, 0x97,
	0x56, 0x96, 0xec, 0x2d, 0xb3, 0x2f, 0x13, 0xa2, 0xcc, 0xe4, 0x65, 0x4a, 0xea, 0x6c, 0xa5, 0x6e,
	0xd4, 0x84, 0x39, 0x00, 0x7b, 0xfa, 0x4e, 0x21, 0xec, 0xcd, 0x1c, 0xfd, 0x6a, 0x79, 0xf8, 0x67,
	0x1f, 0x39, 0x2d, 0x85, 0x7e, 0x85, 0x3d, 0x7d, 0xf4, 0xbf, 0xce, 0x91, 0xea, 0x2a, 0x61, 0xad,
	0xc9, 0x74, 0x7a, 0x5e, 0x92, 0x4e, 0x82, 0xe4, 0xea, 0x7d, 0x84, 0x64, 0x0e, 0xa9, 0x8f, 0x39,
	0x67, 0x6a, 0x5a, 0x28, 0xd0, 0xd7, 0x37, 0xab, 0x00, 0x54, 0x50, 0x60, 0x38, 0x2d, 0x85, 0x9e,
	0x53, 0x90, 0x21, 0x9d, 0x2a, 0x58, 0xbf, 0x87, 0x82, 0xac, 0x33, 0xad, 0x60, 0x04, 0x9e, 0x4c,
	0xf3, 0x3a, 0x5b, 0x89, 0xd3, 0xcb, 0xbd, 0x51, 0x7a, 0xb9, 0xcf, 0x6a, 0xce, 0xa1, 0x4e, 0xef,
	0x94, 0xe3, 0x3b, 0x41, 0x91, 0xde, 0xf3, 0x3f, 0x0c, 0x70, 0x54, 0xe4, 0x44, 0xea, 0x6a, 0x4a,
	0x5d, 0xdf, 0x94, 0xe8, 0xca, 0x50, 0x6b, 0x81, 0x0b, 0xb3, 0x67, 0x35, 0x67, 0x3f, 0x37, 0x1a,
	0xa5, 0x77, 0x5a, 0x70, 0x72, 0xf5, 0x6e, 0x96, 0xeb, 0xad, 0x3b, 0x87, 0xba, 0xee, 0x14, 0xe8,
	0x2d, 0x72, 0x22, 0xf5, 0x6e, 0x3d, 0xa8, 0xde, 0xba, 0xb3, 0x9f, 0x1b, 0x8d, 0xd6, 0x2b, 0xeb,
	0x58, 0xa1, 0xde, 0xed, 0x72, 0xbd, 0x0d, 0xe7, 0x50, 0x91, 0x14, 0xea, 0x2d, 0x70, 0x22, 0xf5,
	0xee, 0x3c, 0xa8, 0xde, 0x86, 0xb3, 0x9f, 0x1b, 0x8d, 0x58, 0x3c, 0xf8, 0x67, 0x05, 0x1c, 0xdd,
	0x56, 0x85, 0xcc, 0x2b, 0xf0, 0xb8, 0xe0, 0xb9, 0x23, 0xbb, 0x7f, 0x79, 0xc3, 0xc9, 0x65, 0xfd,
	0x1d, 0x34, 0x33, 0xaf, 0x26, 0xf9, 0x5e, 0xd8, 0x3c, 0x1d, 0xde, 0xa5, 0x77, 0x2b, 0x32, 0x2d,
	0xbd, 0x70, 0xd5, 0xd9, 0x88, 0x66, 0xbe, 0x74, 0x37, 0xaf, 0x57, 0xee, 0xe6, 0x2f, 0xc1, 0xd6,
	0x7c, 0xb7, 0x6d, 0x54, 0x00, 0x37, 0x59, 0xa6, 0xcb, 0x16, 0xf6, 0xaf, 0xb5, 0x7b, 0xf7, 0x2f,
	0x50, 0xbd, 0x7f, 0x9d, 0x03, 0x73, 0x4c, 0x11, 0xe4, 0x01, 0xc1, 0x33, 0x72, 0xd6, 0x2b, 0x10,
	0x6c, 0x2b, 0x9c, 0x56, 0xd4, 0x07, 0xcd, 0x6c, 0x19, 0x5f, 0xaa, 0xd4, 0x88, 0xd6, 0xd1, 0x4c,
	0xf9, 0x7e, 0x9b, 0x70, 0x4c, 0xab, 0xf6, 0xf2, 0xbd, 0xfa, 0x8e, 0xe0, 0xd6, 0xd5, 0xfa, 0x07,
	0xb0, 0x9b, 0x9f, 0xc4, 0x2b, 0xe5, 0x49, 0x6c, 0x38, 0x2d, 0x96, 0x93, 0xbc, 0xef, 0x40, 0x2b,
	0x2f, 0x65, 0x57, 0x1f, 0x34, 0x65, 0x0d, 0x67, 0x87, 0xcd, 0x4f, 0xf6, 0x01, 0x58, 0x55, 0x1b,
	0xd5, 0xdf, 0x06, 0x9b, 0xd9, 0x28, 0xfa, 0x2d, 0xb0, 0xb3, 0xd0, 0xc7, 0xc5, 0xe4, 0x42, 0x6b,
	0xec, 0xef, 0x83, 0xc7, 0x05, 0xdd, 0x45, 0x2c, 0x15, 0x14, 0x62, 0xb9, 0x94, 0x5f, 0xb3, 0xfa,
	0xff, 0x1b, 0xe0, 0xd9, 0x98, 0x84, 0xe5, 0xaf, 0x9f, 0xbe, 0x39, 0x9f, 0xa2, 0x9c, 0x5c, 0x1a,
	0x6f, 0xcf, 0x53, 0xa0, 0x4f, 0x26, 0x10, 0xfb, 0x36, 0xa1, 0x7e, 0xdb, 0x47, 0x58, 0x9e, 0x89,
	0xfa, 0x8f, 0x89, 0x02, 0x76, 0xcb, 0x7f, 0xde, 0x57, 0x7a, 0xf4, 0x67, 0xad, 0xfe, 0xba, 0xd7,
	0xfb, 0xbb, 0xf6, 0xf4, 0x75, 0x42, 0xd9, 0xf3, 0x98, 0x9d, 0x0c, 0xc5, 0x68, 0xd8, 0xb1, 0x1d,
	0x65, 0xf9, 0xaf, 0xb2, 0xb9, 0xee, 0x79, 0xec, 0x5a, 0xdb, 0x5c, 0x0f, 0x3b, 0xd7, 0xda, 0xe6,
	0xbf, 0xda, 0xb3, 0x64, 0xa1, 0xdb, 0xed, 0x79, 0xac, 0xdb, 0xd5, 0x56, 0xdd, 0xee, 0xb0, 0xd3,
	0xed, 0x6a, 0xbb, 0xd1, 0xb2, 0x0c, 0xf6, 0xf3, 0x0f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x66, 0x97,
	0x24, 0xa4, 0x93, 0x0e, 0x00, 0x00,
}
